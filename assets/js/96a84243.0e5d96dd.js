"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2067],{5419:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return C},default:function(){return N},frontMatter:function(){return k},metadata:function(){return b},toc:function(){return x}});var i=n(7462),r=n(3366),a=n(7294),o=n(3905),s=n(1736),l=n(3136),c=["children","container"],p=["children","container"],h=["children","data","type"],u=["chilren","data"],d=(0,a.createContext)(),f=function(){var e=(0,a.useRef)(null);return a.createElement(m,{width:600,height:400},a.createElement(w,{ref:e,type:"line",data:[{time:"2018-10-11",value:52.89},{time:"2018-10-12",value:51.65},{time:"2018-10-13",value:51.56},{time:"2018-10-14",value:50.19},{time:"2018-10-15",value:51.86},{time:"2018-10-16",value:51.25}]}))};function m(e){var t=(0,a.useState)(!1),n=t[0],r=t[1],o=(0,a.useCallback)((function(e){return r(e)}),[]);return a.createElement("div",{ref:o},n&&a.createElement(g,(0,i.Z)({},e,{container:n})))}var g=(0,a.forwardRef)((function(e,t){var n=(0,a.useRef)({api:function(){if(!this._api){e.children;var t=e.container,n=(0,r.Z)(e,c);this._api=(0,l.C2)(t,n),this._api.timeScale().fitContent()}return this._api},free:function(){this._api&&this._api.remove()}});return(0,a.useLayoutEffect)((function(){n.current.api()}),[]),(0,a.useLayoutEffect)((function(){var t=n.current,i=(e.children,e.container,(0,r.Z)(e,p));t.api().applyOptions(i)}),[e]),(0,a.useImperativeHandle)(t,(function(){return n.current.api()}),[]),a.createElement(d.Provider,{value:n.current},e.children)}));g.displayName="ChartContainer";var w=(0,a.forwardRef)((function(e,t){var n=(0,a.useContext)(d),i=(0,a.useRef)({api:function(){if(!this._api){e.children;var t=e.data,i=e.type,a=(0,r.Z)(e,h);this._api="line"===i?n.api().addLineSeries(a):n.api().addAreaSeries(a),this._api.setData(t)}return this._api},free:function(){this._api&&n.free()}});return(0,a.useLayoutEffect)((function(){var e=i.current;return e.api(),function(){return e.free()}}),[]),(0,a.useLayoutEffect)((function(){var t=i.current,n=(e.chilren,e.data,(0,r.Z)(e,u));t.api().applyOptions(n)}),[e]),(0,a.useImperativeHandle)(t,(function(){return i.current.api()}),[]),a.createElement(d.Provider,{value:i.current},e.children)}));w.displayName="Series";var v=["components"],k={id:"react-complex-example",title:"How to wrap Lightweight Charts into parent/children components",sidebar_position:1},C=void 0,b={unversionedId:"tutorials/react-complex-example",id:"tutorials/react-complex-example",title:"How to wrap Lightweight Charts into parent/children components",description:"The following describes a more complex scenario where a user could imagine splitting the responsibilities of the chart between components.",source:"@site/docs/tutorials/react-complex-example.mdx",sourceDirName:"tutorials",slug:"/tutorials/react-complex-example",permalink:"/lightweight-charts/docs/tutorials/react-complex-example",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"react-complex-example",title:"How to wrap Lightweight Charts into parent/children components",sidebar_position:1},sidebar:"docsSidebar",previous:{title:"How to use Lightweight Charts with React",permalink:"/lightweight-charts/docs/tutorials/react"}},x=[],y={toc:x};function N(e){var t=e.components,n=(0,r.Z)(e,v);return(0,o.kt)("wrapper",(0,i.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"The following describes a more complex scenario where a user could imagine splitting the responsibilities of the chart between components."),(0,o.kt)("p",{parentName:"div"},"If you want to consult a simpler approach please consult this ",(0,o.kt)("a",{parentName:"p",href:"./react"},"example"),"."))),(0,o.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"By following the steps below we assume you're familiar with Lightweight Chart, how to set up a project using it and how to render a chart."),(0,o.kt)("p",{parentName:"div"},"If not, please follow this ",(0,o.kt)("a",{parentName:"p",href:"./react"},"guide"),"."))),(0,o.kt)("p",null,"If you're familiar with Lightweight Chart you probably already know that a ",(0,o.kt)("em",{parentName:"p"},"Chart")," is a container that can contain one or more ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/series-types"},(0,o.kt)("em",{parentName:"a"},"Series")),".\nEach ",(0,o.kt)("em",{parentName:"p"},"Series")," has its own options (for instance ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/api/interfaces/AreaStyleOptions"},"AreaStyleOptions"),", ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/api/interfaces/LineStyleOptions"},"LineStyleOptions"),", etc) in addition to ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/price-scale"},"Price")," and/or ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/time-scale"},"Time")," scale."),(0,o.kt)("p",null,"Based on this principle, one could easily imagine having a main component ",(0,o.kt)("em",{parentName:"p"},"Chart")," that could have some ",(0,o.kt)("em",{parentName:"p"},"Series")," children that could themselves have other children and so on.\nTherefore the structure could become something like"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<Chart component>\n    <Series component 1>\n        <child component />\n    </Series component 1>\n    <Series component n>\n        <child component />\n    </Series component n>\n</Chart component>\n")),(0,o.kt)("p",null,"Even though it's possible to create a Chart without a Series, the complexity arises when another component wants to interact with any of its siblings/parent, like updating a series by adding more data or resizing the chart itself."),(0,o.kt)("p",null,"Given this tutorial is about React this is how we are going to define components relying on React ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-intro.html"},"Hooks")," and ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/composition-vs-inheritance.html"},"composition"),"."),(0,o.kt)("p",null,"However, one drawback with the way React and its hooks like ",(0,o.kt)("em",{parentName:"p"},"useEffect")," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/issues/16728"},"work")," in a parent/children implementation is that their respective hooks are called in a bottom-up order for instanciation but top-to-bottom when it comes to clean-up."),(0,o.kt)("p",null,"The following skeleton illustrates the mechanism."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"ParentComponent = () => {\n    useEffect(() => {\n        // this effect will be triggered in position 3\n\n        return () => {\n            // this clean up will be triggered in position 1\n        };\n    }, []);\n\n    useEffect(() => {\n        // this effect will be triggered in position 4\n\n        return () => {\n            // this clean up will be triggered in position 2\n        };\n    }, []);\n}\n\nChildComponent = () => {\n    useEffect(() => {\n        // this effect will be triggered in position 1\n\n        return () => {\n            // this clean up will be triggered in position 3\n        };\n    }, []);\n\n    useEffect(() => {\n        // this effect will be triggered in position 2\n\n        return () => {\n            // this clean up will be triggered in position 4\n        };\n    }, []);\n}\n")),(0,o.kt)("p",null,"In essence, taking the example above, it means that a ChildComponent (aka Series) would be created first whilst requiring a ParentComponent (aka Chart)."),(0,o.kt)("p",null,"To achieve that, we will have to rely on a few hooks and take advantage of the way they work in addition to use ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/forwarding-refs.html"},"ref/forwardRef")," which is a technique to pass down properties from one component to its children."),(0,o.kt)("p",null,'In the end the "visible" structure and usage will be alike but internally it will be something like:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<Chart component>\n    <ChartContainer>\n        <Series component 1>\n            <child component />\n        </Series component 1>\n        <Series component n>\n            <child component />\n        </Series component n>\n    </ChartContainer>\n</Chart component>\n")),(0,o.kt)("p",null,"where the ChartContainer's role would be needed to attach a DOMElement on which the chart will render.\nChartContainer will be responsible for creating a ",(0,o.kt)("strong",{parentName:"p"},"ref"),"[erence]"," that will hold functions to handle the lifecycle of the chart.\nThat reference will then be propagated down to the Series."),(0,o.kt)("p",null,"The same technique will be used within the Series component to handle this time the lifecycle of any Series along with adding data to be plotted."),(0,o.kt)("p",null,'Moreover those 2 "main" components will "expose" whatever functions the user wants from the internal reference object at a higher level, meaning once those references are accessible any other component would then be able to act on either the Chart or any Series.'),(0,o.kt)("p",null,"Here's a squeleton of what the final structure would be like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"MainComponent = (props) => {\n    // Creates the first reference and instanciate a ParentComponent\n    return (\n        <div ref={chartReference}>\n            <ChartContainer {...props} container={container} />\n        </div>\n    );\n}\n\nParentComponent = forwardRef(props, ref) => {\n    const internalRef = useRef({\n        method_1() {\n            // This function would be responsible for creating the chart for instance\n        },\n        method_n() {\n            // This function would be responsible for cleaning up the chart\n        }\n    });\n\n    useEffect(() => {\n        // this effect will be triggered in position 3\n\n        return () => {\n            // this clean up will be triggered in position 1\n        };\n    }, []);\n\n    useEffect(() => {\n        // this effect will be triggered in position 4\n\n        return () => {\n            // this clean up will be triggered in position 2\n        };\n    }, []);\n\n    useImperativeHandle(ref, () => {\n        // That's the hook responsible for exposing part of/entirety of internalRef\n    }, []);\n\n    // Following bit is to propagate all props & internalRef object down to children\n    return (\n        <Context.Provider value={internalRef.current}>\n            {props.children}\n        </Context.Provider>\n    );\n}\n\nChildComponent = forwardRef(props, ref) => {\n    const internalRef = useRef({\n        method_1() {\n            // This function would be responsible for creating a series\n        },\n        method_n() {\n            // This function would be responsible for removing it\n        }\n    });\n\n    useEffect(() => {\n        // this effect will be triggered in position 1\n\n        return () => {\n            // this clean up will be triggered in position 3\n        };\n    }, []);\n\n    useEffect(() => {\n        // this effect will be triggered in position 2\n\n        return () => {\n            // this clean up will be triggered in position 4\n        };\n    }, []);\n\n    useImperativeHandle(ref, () => {\n        // That's the hook responsible for exposing part of/entirety of internalRef\n    }, []);\n\n    // Following bit is to propagate all props & internalRef object down to children\n    return (\n        <Context.Provider value={internalRef.current}>\n            {props.children}\n        </Context.Provider>\n    );\n}\n")),(0,o.kt)("p",null,"By considering all the above you could end up with Chart/Series components looking like the following"),(0,o.kt)(s.Z,{className:"language-jsx",mdxType:"CodeBlock"},"import { createChart } from 'lightweight-charts';\nimport React, {\n\tcreateContext,\n\tforwardRef,\n\tuseCallback,\n\tuseContext,\n\tuseImperativeHandle,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseState,\n} from 'react';\n\nconst Context = createContext();\n\nexport const App = () => {\n\tconst series1 = useRef(null);\n\n\treturn (\n\t\t<Chart width={600} height={400}>\n\t\t\t<Series\n\t\t\t\tref={series1}\n\t\t\t\ttype={'line'}\n\t\t\t\tdata={[\n\t\t\t\t\t{ time: '2018-10-11', value: 52.89 },\n\t\t\t\t\t{ time: '2018-10-12', value: 51.65 },\n\t\t\t\t\t{ time: '2018-10-13', value: 51.56 },\n\t\t\t\t\t{ time: '2018-10-14', value: 50.19 },\n\t\t\t\t\t{ time: '2018-10-15', value: 51.86 },\n\t\t\t\t\t{ time: '2018-10-16', value: 51.25 },\n\t\t\t\t]}\n\t\t\t/>\n\t\t</Chart>\n\t);\n};\n\nexport function Chart(props) {\n\tconst [container, setContainer] = useState(false);\n\tconst handleRef = useCallback(ref => setContainer(ref), []);\n\treturn (\n\t\t<div ref={handleRef}>\n\t\t\t{container && <ChartContainer {...props} container={container} />}\n\t\t</div>\n\t);\n}\n\nexport const ChartContainer = forwardRef((props, ref) => {\n\tconst context = useRef({\n\t\tapi() {\n\t\t\tif (!this._api) {\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\tconst { children, container, ...rest } = props;\n\t\t\t\tthis._api = createChart(container, rest);\n\t\t\t\tthis._api.timeScale().fitContent();\n\t\t\t}\n\t\t\treturn this._api;\n\t\t},\n\t\tfree() {\n\t\t\tif (this._api) {\n\t\t\t\tthis._api.remove();\n\t\t\t}\n\t\t},\n\t});\n\n\tuseLayoutEffect(() => {\n\t\tconst currentRef = context.current;\n\t\tcurrentRef.api();\n\t}, []);\n\n\tuseLayoutEffect(() => {\n\t\tconst currentRef = context.current;\n\n\t\t// eslint-disable-next-line no-unused-vars\n\t\tconst { children, container, ...rest } = props;\n\t\tcurrentRef.api().applyOptions(rest);\n\t}, [props]);\n\n\tuseImperativeHandle(ref, () => context.current.api(), []);\n\n\treturn (\n\t\t<Context.Provider value={context.current}>\n\t\t\t{props.children}\n\t\t</Context.Provider>\n\t);\n});\nChartContainer.displayName = 'ChartContainer';\n\nexport const Series = forwardRef((props, ref) => {\n\tconst parent = useContext(Context);\n\tconst context = useRef({\n\t\tapi() {\n\t\t\tif (!this._api) {\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\tconst { children, data, type, ...rest } = props;\n\t\t\t\tthis._api = type === 'line' ? parent.api().addLineSeries(rest) : parent.api().addAreaSeries(rest);\n\t\t\t\tthis._api.setData(data);\n\t\t\t}\n\t\t\treturn this._api;\n\t\t},\n\t\tfree() {\n\t\t\tif (this._api) {\n\t\t\t\tparent.free();\n\t\t\t}\n\t\t},\n\t});\n\n\tuseLayoutEffect(() => {\n\t\tconst currentRef = context.current;\n\t\tcurrentRef.api();\n\n\t\treturn () => currentRef.free();\n\t}, []);\n\n\tuseLayoutEffect(() => {\n\t\tconst currentRef = context.current;\n\t\t// eslint-disable-next-line no-unused-vars\n\t\tconst { chilren, data, ...rest } = props;\n\t\tcurrentRef.api().applyOptions(rest);\n\t}, [props]);\n\n\tuseImperativeHandle(ref, () => context.current.api(), []);\n\n\treturn (\n\t\t<Context.Provider value={context.current}>\n\t\t\t{props.children}\n\t\t</Context.Provider>\n\t);\n});\nSeries.displayName = 'Series';\n"),(0,o.kt)("p",null,"The code above will produce a Series of type ",(0,o.kt)("inlineCode",{parentName:"p"},"line")," in a 600x400 Chart.\nGiven a ",(0,o.kt)("inlineCode",{parentName:"p"},"series1")," reference is created to be passed to the Series component you could reuse that object via ",(0,o.kt)("inlineCode",{parentName:"p"},"series1.context.[any function applicable on Series]"),", for instance ",(0,o.kt)("inlineCode",{parentName:"p"},"series1.context.update(new data)"),"."),(0,o.kt)(f,{mdxType:"App"}))}N.isMDXComponent=!0}}]);